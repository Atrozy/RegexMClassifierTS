"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./lib/classifier.ts":
/*!***************************!*\
  !*** ./lib/classifier.ts ***!
  \***************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   classifySentence: () => (/* binding */ classifySentence)\n/* harmony export */ });\n// lib/classifier.ts\nconst regularWeight = 1.0;\nconst highWeightMultiplier = 5.0;\nconst regexWeight = 0.3;\nconst keywords = {\n    'Academic': [\n        'journal',\n        'professor'\n    ],\n    'Code': [\n        'function',\n        'debug'\n    ]\n};\nconst highKeywords = {\n    'Academic': [\n        'journal',\n        'professor'\n    ],\n    'Code': [\n        'function',\n        'debug'\n    ]\n};\nfunction calculateRegexScores(query, keywords, regexWeight, highKeywords) {\n    const scores = {};\n    for(const category in keywords){\n        const words = keywords[category];\n        const matchedKeywords = words.filter((word)=>query.includes(word));\n        const categoryScore = matchedKeywords.reduce((acc, word)=>{\n            var _highKeywords_category;\n            return acc + (((_highKeywords_category = highKeywords[category]) === null || _highKeywords_category === void 0 ? void 0 : _highKeywords_category.includes(word)) ? highWeightMultiplier : regularWeight);\n        }, 0);\n        scores[category] = categoryScore * regexWeight;\n        console.log(\"Matched keywords for \".concat(category, \": \").concat(matchedKeywords));\n    }\n    return scores;\n}\nfunction normalizeScores(scores) {\n    const total = Object.values(scores).reduce((acc, score)=>acc + score, 0);\n    if (total > 0) {\n        return Object.fromEntries(Object.entries(scores).map((param)=>{\n            let [category, score] = param;\n            return [\n                category,\n                score / total\n            ];\n        }));\n    } else {\n        const numCategories = Object.keys(scores).length;\n        return Object.fromEntries(Object.keys(scores).map((category)=>[\n                category,\n                1 / numCategories\n            ]));\n    }\n}\nfunction filterLowConfidenceIntents(scores) {\n    let threshold = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.2;\n    return Object.fromEntries(Object.entries(scores).filter((param)=>{\n        let [, score] = param;\n        return score >= threshold;\n    }));\n}\nfunction classifySentence(sentence) {\n    const startTime = Date.now();\n    const regexScores = calculateRegexScores(sentence, keywords, regexWeight, highKeywords);\n    const normalizedScores = normalizeScores(regexScores);\n    const filteredScores = filterLowConfidenceIntents(normalizedScores, 0.2);\n    const processingTime = (Date.now() - startTime) / 1000;\n    return [\n        filteredScores,\n        processingTime\n    ];\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvY2xhc3NpZmllci50cyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsb0JBQW9CO0FBS3BCLE1BQU1BLGdCQUFnQjtBQUN0QixNQUFNQyx1QkFBdUI7QUFDN0IsTUFBTUMsY0FBYztBQUVwQixNQUFNQyxXQUFvQjtJQUN4QixZQUFZO1FBQUM7UUFBVztLQUFZO0lBQ3BDLFFBQVE7UUFBQztRQUFZO0tBQVE7QUFDL0I7QUFFQSxNQUFNQyxlQUF3QjtJQUM1QixZQUFZO1FBQUM7UUFBVztLQUFZO0lBQ3BDLFFBQVE7UUFBQztRQUFZO0tBQVE7QUFDL0I7QUFFQSxTQUFTQyxxQkFDUEMsS0FBYSxFQUNiSCxRQUFpQixFQUNqQkQsV0FBbUIsRUFDbkJFLFlBQXFCO0lBRXJCLE1BQU1HLFNBQWlCLENBQUM7SUFFeEIsSUFBSyxNQUFNQyxZQUFZTCxTQUFVO1FBQy9CLE1BQU1NLFFBQVFOLFFBQVEsQ0FBQ0ssU0FBUztRQUNoQyxNQUFNRSxrQkFBa0JELE1BQU1FLE1BQU0sQ0FBQ0MsQ0FBQUEsT0FBUU4sTUFBTU8sUUFBUSxDQUFDRDtRQUU1RCxNQUFNRSxnQkFBZ0JKLGdCQUFnQkssTUFBTSxDQUFDLENBQUNDLEtBQUtKO2dCQUNuQ1I7WUFBZCxPQUFPWSxNQUFPWixDQUFBQSxFQUFBQSx5QkFBQUEsWUFBWSxDQUFDSSxTQUFTLGNBQXRCSiw2Q0FBQUEsdUJBQXdCUyxRQUFRLENBQUNELFNBQVFYLHVCQUF1QkQsYUFBWTtRQUM1RixHQUFHO1FBRUhPLE1BQU0sQ0FBQ0MsU0FBUyxHQUFHTSxnQkFBZ0JaO1FBQ25DZSxRQUFRQyxHQUFHLENBQUMsd0JBQXFDUixPQUFiRixVQUFTLE1BQW9CLE9BQWhCRTtJQUNuRDtJQUVBLE9BQU9IO0FBQ1Q7QUFFQSxTQUFTWSxnQkFBZ0JaLE1BQWM7SUFDckMsTUFBTWEsUUFBUUMsT0FBT0MsTUFBTSxDQUFDZixRQUFRUSxNQUFNLENBQUMsQ0FBQ0MsS0FBS08sUUFBVVAsTUFBTU8sT0FBTztJQUN4RSxJQUFJSCxRQUFRLEdBQUc7UUFDYixPQUFPQyxPQUFPRyxXQUFXLENBQ3ZCSCxPQUFPSSxPQUFPLENBQUNsQixRQUFRbUIsR0FBRyxDQUFDO2dCQUFDLENBQUNsQixVQUFVZSxNQUFNO21CQUFLO2dCQUFDZjtnQkFBVWUsUUFBUUg7YUFBTTs7SUFFL0UsT0FBTztRQUNMLE1BQU1PLGdCQUFnQk4sT0FBT08sSUFBSSxDQUFDckIsUUFBUXNCLE1BQU07UUFDaEQsT0FBT1IsT0FBT0csV0FBVyxDQUN2QkgsT0FBT08sSUFBSSxDQUFDckIsUUFBUW1CLEdBQUcsQ0FBQ2xCLENBQUFBLFdBQVk7Z0JBQUNBO2dCQUFVLElBQUltQjthQUFjO0lBRXJFO0FBQ0Y7QUFFQSxTQUFTRywyQkFBMkJ2QixNQUFjO1FBQUV3QixZQUFBQSxpRUFBWTtJQUM5RCxPQUFPVixPQUFPRyxXQUFXLENBQUNILE9BQU9JLE9BQU8sQ0FBQ2xCLFFBQVFJLE1BQU0sQ0FBQztZQUFDLEdBQUdZLE1BQU07ZUFBS0EsU0FBU1E7O0FBQ2xGO0FBRU8sU0FBU0MsaUJBQ2RDLFFBQWdCO0lBRWhCLE1BQU1DLFlBQVlDLEtBQUtDLEdBQUc7SUFFMUIsTUFBTUMsY0FBY2hDLHFCQUFxQjRCLFVBQVU5QixVQUFVRCxhQUFhRTtJQUMxRSxNQUFNa0MsbUJBQW1CbkIsZ0JBQWdCa0I7SUFDekMsTUFBTUUsaUJBQWlCVCwyQkFBMkJRLGtCQUFrQjtJQUVwRSxNQUFNRSxpQkFBaUIsQ0FBQ0wsS0FBS0MsR0FBRyxLQUFLRixTQUFRLElBQUs7SUFDbEQsT0FBTztRQUFDSztRQUFnQkM7S0FBZTtBQUN6QyIsInNvdXJjZXMiOlsiRTpcXHJlZ3h0c1xcbGliXFxjbGFzc2lmaWVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGxpYi9jbGFzc2lmaWVyLnRzXHJcblxyXG50eXBlIEludGVudHMgPSB7IFtjYXRlZ29yeTogc3RyaW5nXTogc3RyaW5nW10gfTtcclxudHlwZSBTY29yZXMgPSB7IFtjYXRlZ29yeTogc3RyaW5nXTogbnVtYmVyIH07XHJcblxyXG5jb25zdCByZWd1bGFyV2VpZ2h0ID0gMS4wO1xyXG5jb25zdCBoaWdoV2VpZ2h0TXVsdGlwbGllciA9IDUuMDtcclxuY29uc3QgcmVnZXhXZWlnaHQgPSAwLjM7XHJcblxyXG5jb25zdCBrZXl3b3JkczogSW50ZW50cyA9IHtcclxuICAnQWNhZGVtaWMnOiBbJ2pvdXJuYWwnLCAncHJvZmVzc29yJ10sXHJcbiAgJ0NvZGUnOiBbJ2Z1bmN0aW9uJywgJ2RlYnVnJ10sXHJcbn07XHJcblxyXG5jb25zdCBoaWdoS2V5d29yZHM6IEludGVudHMgPSB7XHJcbiAgJ0FjYWRlbWljJzogWydqb3VybmFsJywgJ3Byb2Zlc3NvciddLFxyXG4gICdDb2RlJzogWydmdW5jdGlvbicsICdkZWJ1ZyddLFxyXG59O1xyXG5cclxuZnVuY3Rpb24gY2FsY3VsYXRlUmVnZXhTY29yZXMoXHJcbiAgcXVlcnk6IHN0cmluZyxcclxuICBrZXl3b3JkczogSW50ZW50cyxcclxuICByZWdleFdlaWdodDogbnVtYmVyLFxyXG4gIGhpZ2hLZXl3b3JkczogSW50ZW50c1xyXG4pOiBTY29yZXMge1xyXG4gIGNvbnN0IHNjb3JlczogU2NvcmVzID0ge307XHJcblxyXG4gIGZvciAoY29uc3QgY2F0ZWdvcnkgaW4ga2V5d29yZHMpIHtcclxuICAgIGNvbnN0IHdvcmRzID0ga2V5d29yZHNbY2F0ZWdvcnldO1xyXG4gICAgY29uc3QgbWF0Y2hlZEtleXdvcmRzID0gd29yZHMuZmlsdGVyKHdvcmQgPT4gcXVlcnkuaW5jbHVkZXMod29yZCkpO1xyXG5cclxuICAgIGNvbnN0IGNhdGVnb3J5U2NvcmUgPSBtYXRjaGVkS2V5d29yZHMucmVkdWNlKChhY2MsIHdvcmQpID0+IHtcclxuICAgICAgcmV0dXJuIGFjYyArIChoaWdoS2V5d29yZHNbY2F0ZWdvcnldPy5pbmNsdWRlcyh3b3JkKSA/IGhpZ2hXZWlnaHRNdWx0aXBsaWVyIDogcmVndWxhcldlaWdodCk7XHJcbiAgICB9LCAwKTtcclxuXHJcbiAgICBzY29yZXNbY2F0ZWdvcnldID0gY2F0ZWdvcnlTY29yZSAqIHJlZ2V4V2VpZ2h0O1xyXG4gICAgY29uc29sZS5sb2coYE1hdGNoZWQga2V5d29yZHMgZm9yICR7Y2F0ZWdvcnl9OiAke21hdGNoZWRLZXl3b3Jkc31gKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBzY29yZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVNjb3JlcyhzY29yZXM6IFNjb3Jlcyk6IFNjb3JlcyB7XHJcbiAgY29uc3QgdG90YWwgPSBPYmplY3QudmFsdWVzKHNjb3JlcykucmVkdWNlKChhY2MsIHNjb3JlKSA9PiBhY2MgKyBzY29yZSwgMCk7XHJcbiAgaWYgKHRvdGFsID4gMCkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcclxuICAgICAgT2JqZWN0LmVudHJpZXMoc2NvcmVzKS5tYXAoKFtjYXRlZ29yeSwgc2NvcmVdKSA9PiBbY2F0ZWdvcnksIHNjb3JlIC8gdG90YWxdKVxyXG4gICAgKTtcclxuICB9IGVsc2Uge1xyXG4gICAgY29uc3QgbnVtQ2F0ZWdvcmllcyA9IE9iamVjdC5rZXlzKHNjb3JlcykubGVuZ3RoO1xyXG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcclxuICAgICAgT2JqZWN0LmtleXMoc2NvcmVzKS5tYXAoY2F0ZWdvcnkgPT4gW2NhdGVnb3J5LCAxIC8gbnVtQ2F0ZWdvcmllc10pXHJcbiAgICApO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZmlsdGVyTG93Q29uZmlkZW5jZUludGVudHMoc2NvcmVzOiBTY29yZXMsIHRocmVzaG9sZCA9IDAuMik6IFNjb3JlcyB7XHJcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhzY29yZXMpLmZpbHRlcigoWywgc2NvcmVdKSA9PiBzY29yZSA+PSB0aHJlc2hvbGQpKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNsYXNzaWZ5U2VudGVuY2UoXHJcbiAgc2VudGVuY2U6IHN0cmluZ1xyXG4pOiBbU2NvcmVzLCBudW1iZXJdIHtcclxuICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xyXG5cclxuICBjb25zdCByZWdleFNjb3JlcyA9IGNhbGN1bGF0ZVJlZ2V4U2NvcmVzKHNlbnRlbmNlLCBrZXl3b3JkcywgcmVnZXhXZWlnaHQsIGhpZ2hLZXl3b3Jkcyk7XHJcbiAgY29uc3Qgbm9ybWFsaXplZFNjb3JlcyA9IG5vcm1hbGl6ZVNjb3JlcyhyZWdleFNjb3Jlcyk7XHJcbiAgY29uc3QgZmlsdGVyZWRTY29yZXMgPSBmaWx0ZXJMb3dDb25maWRlbmNlSW50ZW50cyhub3JtYWxpemVkU2NvcmVzLCAwLjIpO1xyXG5cclxuICBjb25zdCBwcm9jZXNzaW5nVGltZSA9IChEYXRlLm5vdygpIC0gc3RhcnRUaW1lKSAvIDEwMDA7XHJcbiAgcmV0dXJuIFtmaWx0ZXJlZFNjb3JlcywgcHJvY2Vzc2luZ1RpbWVdO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJyZWd1bGFyV2VpZ2h0IiwiaGlnaFdlaWdodE11bHRpcGxpZXIiLCJyZWdleFdlaWdodCIsImtleXdvcmRzIiwiaGlnaEtleXdvcmRzIiwiY2FsY3VsYXRlUmVnZXhTY29yZXMiLCJxdWVyeSIsInNjb3JlcyIsImNhdGVnb3J5Iiwid29yZHMiLCJtYXRjaGVkS2V5d29yZHMiLCJmaWx0ZXIiLCJ3b3JkIiwiaW5jbHVkZXMiLCJjYXRlZ29yeVNjb3JlIiwicmVkdWNlIiwiYWNjIiwiY29uc29sZSIsImxvZyIsIm5vcm1hbGl6ZVNjb3JlcyIsInRvdGFsIiwiT2JqZWN0IiwidmFsdWVzIiwic2NvcmUiLCJmcm9tRW50cmllcyIsImVudHJpZXMiLCJtYXAiLCJudW1DYXRlZ29yaWVzIiwia2V5cyIsImxlbmd0aCIsImZpbHRlckxvd0NvbmZpZGVuY2VJbnRlbnRzIiwidGhyZXNob2xkIiwiY2xhc3NpZnlTZW50ZW5jZSIsInNlbnRlbmNlIiwic3RhcnRUaW1lIiwiRGF0ZSIsIm5vdyIsInJlZ2V4U2NvcmVzIiwibm9ybWFsaXplZFNjb3JlcyIsImZpbHRlcmVkU2NvcmVzIiwicHJvY2Vzc2luZ1RpbWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/classifier.ts\n"));

/***/ })

});